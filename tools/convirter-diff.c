#include <convirter/mtree/entry.h>
#include <convirter/mtree/xattr.h>
#include <convirter/oci-r/index.h>
#include <convirter/oci-r/layer.h>
#include <convirter/oci-r/manifest.h>

#include <errno.h>
#include <fcntl.h>
#include <getopt.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/sysmacros.h>
#include <time.h>
#include <unistd.h>

#include "../common/guestfs.h"

static const char usage[] = "\
Usage: %s [OPTION]... INPUT1 INPUT2\n\
Compare file tree\n\
\n\
      --ignore-c2v     Ignore special path generated by c2v\n\
      --skip-checksum  Do not compare checksum on regular files\n\
\n\
INPUTs are in FORMAT:FILE, where FORMAT is either disk-image or oci-archive\n";

static const struct option long_options[] = {
	{"ignore-c2v",		no_argument,	NULL,	1},
	{"skip-checksum",	no_argument,	NULL,	2},
	{0},
};

static bool ignore_c2v = false;
static bool skip_checksum = false;

static const char *mode_type_string(mode_t mode) {
	switch (mode & S_IFMT) {
	case S_IFSOCK:
		return "socket";
	case S_IFLNK:
		return "symbolic link";
	case S_IFREG:
		return "regular file";
	case S_IFBLK:
		return "block device";
	case S_IFDIR:
		return "directory";
	case S_IFCHR:
		return "character device";
	case S_IFIFO:
		return "FIFO";
	}
	return "unknown";
}

static bool compare_stat(struct stat *a, struct stat *b, const char *path) {
	if ((a->st_mode & S_IFMT) != (b->st_mode & S_IFMT)) {
		printf("File a/%s is a %s while file b/%s is a %s\n", path,
			mode_type_string(a->st_mode), path, mode_type_string(b->st_mode));
		return true;
	}
	if (a->st_mode != b->st_mode) {
		printf("File a/%s is %o while file b/%s is %o\n", path,
			a->st_mode & 07777, path, b->st_mode & 07777);
		return true;
	}
	if (a->st_uid != b->st_uid || a->st_gid != b->st_gid) {
		printf("File a/%s is owned by %d:%d while file b/%s is owned by %d:%d\n",
			path, a->st_uid, a->st_gid, path, b->st_uid, b->st_gid);
		return true;
	}
	if ((S_ISCHR(a->st_mode) || S_ISBLK(a->st_mode)) && a->st_rdev != b->st_rdev) {
		printf("File a/%s is %d:%d while file b/%s is %d:%d\n",
			path, major(a->st_rdev), minor(a->st_rdev),
			path, major(b->st_rdev), minor(b->st_rdev));
		return true;
	}
	if (S_ISREG(a->st_mode) && a->st_size != b->st_size) {
		printf("File a/%s has %ld bytes while file b/%s has %ld bytes\n",
			path, a->st_size, path, b->st_size);
		return true;
	}
	if (a->st_mtime != b->st_mtime) {
		printf("File a/%s and file b/%s have different mtime\n", path, path);
		return true;
	}
	if (a->st_atime && b->st_atime && a->st_atime != b->st_atime) {
		printf("File a/%s and file b/%s have different atime\n", path, path);
		return true;
	}
	return false;
}

static bool compare_xattr(struct cvirt_mtree_inode *a, struct cvirt_mtree_inode *b, const char *path) {
	bool b_compared[b->xattrs_len];
	memset(b_compared, 0, sizeof(bool) * b->xattrs_len);
	for (int i = 0; i < a->xattrs_len; i++) {
		bool found = false;
		for (int j = 0; j < b->xattrs_len; j++) {
			if (b_compared[j]) {
				continue;
			}
			if (!strcmp(a->xattrs[i].name,
					b->xattrs[j].name)) {
				found = true;
				b_compared[j] = true;
				if (a->xattrs[i].len != b->xattrs[j].len ||
						memcmp(a->xattrs[i].value,
						b->xattrs[j].value, a->xattrs[i].len)) {
					printf("File a/%s and file b/%s have different xattr %s value\n",
						path, path, a->xattrs[i].name);
					return true;
				}
			}
		}
		if (!found) {
			printf("File b/%s has xattr %s while file a/%s does not\n",
				path, a->xattrs[i].name, path);
			return true;
		}
	}
	for (int j = 0; j < b->xattrs_len; j++) {
		if (!b_compared[j]) {
			printf("File b/%s has xattr %s while file a/%s does not\n",
				path, b->xattrs[j].name, path);
			return true;
		}
	}
	return false;
}

static bool diff_tree(const struct cvirt_mtree_entry *a, const struct cvirt_mtree_entry *b, const char *path) {
	int res = 0;
	bool differs = false;
	if (ignore_c2v && !strcmp(".c2v", path)) {
		return false;
	}
	if (path[0] != '\0') { //TODO compare root?
		res = compare_stat(&a->inode->stat, &b->inode->stat, path);
		if (res) {
			return true;
		}
		res = compare_xattr(a->inode, b->inode, path);
		if (res) {
			return true;
		}
	}

	if (S_ISREG(a->inode->stat.st_mode)) {
		if ((!skip_checksum) &&
				memcmp(a->inode->sha256sum, b->inode->sha256sum, 32)) {
			printf("File a/%s and file b/%s have different content\n", path, path);
			return true;
		}
	} else if (S_ISLNK(a->inode->stat.st_mode)) {
		if (strcmp(a->inode->target, b->inode->target)) {
			printf("File a/%s and file b/%s have different link target\n", path, path);
			return true;
		}
	} else if (S_ISDIR(a->inode->stat.st_mode)) {
		bool b_compared[b->inode->children_len];
		memset(b_compared, 0, sizeof(bool) * b->inode->children_len);
		for (int i = 0; i < a->inode->children_len; i++) {
			bool found = false;
			if (ignore_c2v && !path[0] &&
					!strcmp(".c2v", a->inode->children[i].name)) {
				continue;
			}
			for (int j = 0; j < b->inode->children_len; j++) {
				if (b_compared[j]) {
					continue;
				}
				if (!strcmp(a->inode->children[i].name,
						b->inode->children[j].name)) {
					char npath[strlen(path) + strlen(a->inode->children[i].name) + 2];
					if (path[0]) {
						strcpy(npath, path);
						strcat(npath, "/");
						strcat(npath, a->inode->children[i].name);
					} else {
						strcpy(npath, a->inode->children[i].name);
					}
					found = true;
					b_compared[j] = true;
					if (diff_tree(&a->inode->children[i],
							&b->inode->children[j], npath)) {
						differs = true;
					}
					break;
				}
			}
			if (!found) {
				printf("Only in a/%s: %s\n", path, a->inode->children[i].name);
				differs = true;
			}
		}
		for (int j = 0; j < b->inode->children_len; j++) {
			if (ignore_c2v && !path[0] &&
					!strcmp(".c2v", b->inode->children[j].name)) {
				continue;
			}
			if (!b_compared[j]) {
				printf("Only in b/%s: %s\n", path, b->inode->children[j].name);
				differs = true;
			}
		}
	}
	return differs;
}

static struct cvirt_mtree_entry *get_tree_from_arg(const char *arg, uint32_t flags) {
	struct cvirt_mtree_entry *tree;
	if (!strncmp(arg, "disk-image:", 11)) {
		guestfs_h *guestfs = create_guestfs_mount_first_linux(&arg[11], NULL);
		if (!guestfs) {
			exit(2);
		}

		tree = cvirt_mtree_tree_from_guestfs(guestfs, flags);

		guestfs_umount_all(guestfs);
		guestfs_shutdown(guestfs);
		guestfs_close(guestfs);
	} else if (!strncmp(arg, "oci-archive:", 12)) {
		int fd = open(&arg[12], O_RDONLY | O_CLOEXEC);
		if (fd < 0) {
			fprintf(stderr, "Failed to open OCI archive: %s\n", strerror(errno));
			exit(2);
		}
		struct cvirt_oci_r_index *index = cvirt_oci_r_index_from_archive(fd);
		const char *manifest_digest = cvirt_oci_r_index_get_native_manifest_digest(index);
		struct cvirt_oci_r_manifest *manifest = cvirt_oci_r_manifest_from_archive_blob(fd, manifest_digest);
		const char *layer_digest = cvirt_oci_r_manifest_get_layer_digest(manifest, 0);
		struct cvirt_oci_r_layer *layer =
			cvirt_oci_r_layer_from_archive_blob(fd, layer_digest,
			cvirt_oci_r_manifest_get_layer_compression(manifest, 0));
		tree = cvirt_mtree_tree_from_oci_layer(layer, flags);
		cvirt_oci_r_layer_destroy(layer);
		int len = cvirt_oci_r_manifest_get_layers_length(manifest);
		for (int i = 1; i < len; i++) {
			struct cvirt_oci_r_layer *layer =
				cvirt_oci_r_layer_from_archive_blob(fd,
				cvirt_oci_r_manifest_get_layer_digest(manifest, i),
				cvirt_oci_r_manifest_get_layer_compression(manifest, i));
			cvirt_mtree_tree_oci_apply_layer(tree, layer, flags);
			cvirt_oci_r_layer_destroy(layer);
		}
		cvirt_oci_r_manifest_destroy(manifest);
		cvirt_oci_r_index_destroy(index);
		close(fd);
	} else {
		fprintf(stderr, "Unrecognized input: %s\n", arg);
		exit(2);
	}
	return tree;
}

int main(int argc, char *argv[]) {
	int opt;
	while ((opt = getopt_long(argc, argv, "", long_options, NULL)) != -1) {
		switch (opt) {
		case '?':
			fprintf(stderr, usage, argv[0]);
			exit(2);
		case 1:
			ignore_c2v = true;
			break;
		case 2:
			skip_checksum = true;
			break;
		}
	}

	if (optind + 2 != argc) {
		fprintf(stderr, usage, argv[0]);
		exit(2);
	}

	uint32_t flags = skip_checksum ? 0 : CVIRT_MTREE_TREE_CHECKSUM;
	struct cvirt_mtree_entry *a = get_tree_from_arg(argv[optind], flags);
	struct cvirt_mtree_entry *b = get_tree_from_arg(argv[optind + 1], flags);
	bool differs = diff_tree(a, b, "");
	cvirt_mtree_tree_destroy(a);
	cvirt_mtree_tree_destroy(b);

	return differs ? 1 : 0;
}
